<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小龙播客</title>
  
  <subtitle>小龙播客</subtitle>
  <link href="https://xiaoyvlongoing.github.io/atom.xml" rel="self"/>
  
  <link href="https://xiaoyvlongoing.github.io/"/>
  <updated>2021-06-09T16:53:23.383Z</updated>
  <id>https://xiaoyvlongoing.github.io/</id>
  
  <author>
    <name>小龙</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://xiaoyvlongoing.github.io/2021/06/10/%E6%96%87%E6%9C%AC%E6%91%98%E8%A6%81%E9%A1%B9%E7%9B%AE/"/>
    <id>https://xiaoyvlongoing.github.io/2021/06/10/%E6%96%87%E6%9C%AC%E6%91%98%E8%A6%81%E9%A1%B9%E7%9B%AE/</id>
    <published>2021-06-09T16:52:48.077Z</published>
    <updated>2021-06-09T16:53:23.383Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1：文本摘要项目理论"><a href="#1：文本摘要项目理论" class="headerlink" title="1：文本摘要项目理论"></a><strong>1：文本摘要项目理论</strong></h2><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p><strong>文本摘要思想</strong>：就是一个长文本把重要的摘要出来</p><h5 id="1：NLP角度来看文本摘要任务，主流的概括两大方法："><a href="#1：NLP角度来看文本摘要任务，主流的概括两大方法：" class="headerlink" title="1：NLP角度来看文本摘要任务，主流的概括两大方法："></a>1：NLP角度来看文本摘要任务，主流的概括两大方法：</h5><ul><li><p>抽取式摘要：Extraction-based（从文本中抽取）：直接从原文中选择若干条重要的句子, 并对它们进行排序和重组, 以形成摘要的方法.</p><ul><li><strong>无监督抽取</strong>：不需要平行语料, 节省了人工标记的成本. 大体上有如下几种:<ul><li>Lead</li><li>Centroid</li><li>ClusterCMRW</li><li>TextRank：最经典</li></ul></li><li><strong>有监督抽取：</strong>将文本摘要抽象成二分类问题, 通过神经网络来学习句子及其标签之间的对应关系. 需要平行语料, 需要人工标记的成本. 常见方法有如下几种<ul><li>R2N2</li><li>NeuralSum</li><li>SummaRuNNer</li><li><strong>BertSum</strong>：原本用来计算网页之间的关联性，后来被应用在句子上，句子之间反复传播，选出最关键的语句进行排序。因为文章总有中心句，而textrank就试图找出这个中心句。</li></ul></li><li>取式<strong>缺点</strong>：主要考虑单词词频，没有过多的语义信息，所以无法建立段落中的完整语义信息</li></ul></li><li><p><strong>生成式摘要: Abstraction-based：</strong>需要通过<strong>转述、同义替换、句子缩写</strong>等生成。</p><ul><li>生成式神经网络模型的基本结构主要由<strong>编码器（encoder）和解码器（decoder）</strong>组成，编码和解码都由神经网络实现。<ul><li><strong>编码器</strong>负责将输入的原文本编码成一个<strong>向量C（context），</strong></li><li><strong>而解码器</strong>负责从这个<strong>向量C</strong>提取<strong>重要信息、加工剪辑，生成文本摘要。</strong></li><li><strong>Sequence-to-Sequence</strong>（以下简称Seq2Seq），被广泛应用于存在输入序列和输出序列的场景，比如机器翻译（一种语言序列到另一种语言序列）、image captioning（图片像素序列到语言序列）、对话机器人（如问题到回答）等</li></ul></li></ul></li></ul><h4 id="2：数据的处理："><a href="#2：数据的处理：" class="headerlink" title="2：数据的处理："></a>2：数据的处理：</h4><p>一般来说, 在任何项目中, 面对原始数据都要进行接下来的几点工作:</p><ul><li>删除空值.</li><li>删除”脏”数据.<ul><li>在这个数据集中的脏数据为：<ul><li>有很多的技师说和，车主说</li><li>文本中有很多的图片字样和语音字样</li><li>有很多进口，车型，还有一些符号</li></ul></li></ul></li><li>删除特定字符的集合.</li><li>分词.</li><li>完成字符到id的映射.</li><li>完成padding, cutting的工作.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">train_path = <span class="string">&#x27;train.csv&#x27;</span></span><br><span class="line">test_path = <span class="string">&#x27;test.csv&#x27;</span></span><br><span class="line"></span><br><span class="line">df = pd.read_csv(train_path, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">df.info()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;**********************&#x27;</span>)</span><br><span class="line"></span><br><span class="line">df = pd.read_csv(test_path, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">df.info()</span><br></pre></td></tr></table></figure><h4 id="打印："><a href="#打印：" class="headerlink" title="打印："></a>打印：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">pandas</span>.<span class="title">core</span>.<span class="title">frame</span>.<span class="title">DataFrame</span>&#x27;&gt;</span></span><br><span class="line"><span class="class"><span class="title">RangeIndex</span>:</span> <span class="number">82943</span> entries, <span class="number">0</span> to <span class="number">82942</span></span><br><span class="line">Data columns (total <span class="number">6</span> columns):</span><br><span class="line"> <span class="comment">#   Column    Non-Null Count  Dtype </span></span><br><span class="line"></span><br><span class="line"> <span class="number">0</span>   QID       <span class="number">82943</span> non-null  <span class="built_in">object</span></span><br><span class="line"> <span class="number">1</span>   Brand     <span class="number">81642</span> non-null  <span class="built_in">object</span></span><br><span class="line"> <span class="number">2</span>   Model     <span class="number">81642</span> non-null  <span class="built_in">object</span></span><br><span class="line"> <span class="number">3</span>   Question  <span class="number">82943</span> non-null  <span class="built_in">object</span></span><br><span class="line"> <span class="number">4</span>   Dialogue  <span class="number">82941</span> non-null  <span class="built_in">object</span></span><br><span class="line"> <span class="number">5</span>   Report    <span class="number">82873</span> non-null  <span class="built_in">object</span></span><br><span class="line">dtypes: <span class="built_in">object</span>(<span class="number">6</span>)</span><br><span class="line">memory usage: <span class="number">3.8</span>+ MB</span><br><span class="line"></span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">pandas</span>.<span class="title">core</span>.<span class="title">frame</span>.<span class="title">DataFrame</span>&#x27;&gt;</span></span><br><span class="line"><span class="class"><span class="title">RangeIndex</span>:</span> <span class="number">20000</span> entries, <span class="number">0</span> to <span class="number">19999</span></span><br><span class="line">Data columns (total <span class="number">5</span> columns):</span><br><span class="line"> <span class="comment">#   Column    Non-Null Count  Dtype </span></span><br><span class="line"></span><br><span class="line"> <span class="number">0</span>   QID       <span class="number">20000</span> non-null  <span class="built_in">object</span></span><br><span class="line"> <span class="number">1</span>   Brand     <span class="number">19987</span> non-null  <span class="built_in">object</span></span><br><span class="line"> <span class="number">2</span>   Model     <span class="number">19987</span> non-null  <span class="built_in">object</span></span><br><span class="line"> <span class="number">3</span>   Question  <span class="number">20000</span> non-null  <span class="built_in">object</span></span><br><span class="line"> <span class="number">4</span>   Dialogue  <span class="number">20000</span> non-null  <span class="built_in">object</span></span><br><span class="line">dtypes: <span class="built_in">object</span>(<span class="number">5</span>)</span><br><span class="line">memory usage: <span class="number">781.4</span>+ KB</span><br></pre></td></tr></table></figure><h4 id="3：TextRank：算法理论基础"><a href="#3：TextRank：算法理论基础" class="headerlink" title="3：TextRank：算法理论基础"></a>3：TextRank：算法理论基础</h4><p>对比于衡量网页重要性的PageRank算法, TextRank算法用于衡量哪些单词是关键词, 类比之下的算法思想也就很好理解了:</p><ul><li>如果一个单词出现在很多单词的后面, 就是它和很多单词有关联, 那么说明这个单词比较重要.</li><li>如果一个TextRank值很高的单词后面跟着另一个单词, 那么后面这个单词的TextRank值也会相应的被提高.</li></ul><h4 id="3-1：TextRank算法代码实践"><a href="#3-1：TextRank算法代码实践" class="headerlink" title="3.1：TextRank算法代码实践"></a>3.1：TextRank算法代码实践</h4><ul><li>在本小节中, 我们仅以示例代码跑通几段小程序, 让同学们掌握如何具体在代码层面用TextRank.<ul><li>关键词抽取(keyword extraction)：是指从文本中确定一些能够描述文档含义的关键术语的过程<ul><li>对关键词抽取而言, 用于构建顶点集的文本单元可以使句子中的一个或多个字. 根据这些字之间的关系构建边.</li><li>根据任务的需要, 可以使用语法过滤器(syntactic filters)对顶点集进行优化. 语法过滤器的主要作用是将某一类或者某几类词性的字过滤出来作为顶点集.</li></ul></li><li>关键短语抽取(keyphrase extraction)</li><li>关键句抽取(sentence extraction)</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="comment"># 导入textrank4zh的相关工具包</span></span><br><span class="line"><span class="keyword">from</span> textrank4zh <span class="keyword">import</span> TextRank4Keyword, TextRank4Sentence</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="comment"># 导入常用工具包</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment">#关键词抽取</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">keywords_extraction</span>(<span class="params">text</span>):</span></span><br><span class="line">    <span class="comment"># allow_speech_tags : 词性列表, 用于过滤某些词性的词</span></span><br><span class="line">    tr4w = TextRank4Keyword(allow_speech_tags=[<span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;nr&#x27;</span>, <span class="string">&#x27;nrfg&#x27;</span>, <span class="string">&#x27;ns&#x27;</span>, <span class="string">&#x27;nt&#x27;</span>, <span class="string">&#x27;nz&#x27;</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># text: 文本内容, 字符串</span></span><br><span class="line">    <span class="comment"># window: 窗口大小, int, 用来构造单词之间的边, 默认值为2</span></span><br><span class="line">    <span class="comment"># lower: 是否将英文文本转换为小写, 默认值为False</span></span><br><span class="line">    <span class="comment"># vertex_source: 选择使用words_no_filter, words_no_stop_words, words_all_filters中的&gt;哪一个来构造pagerank对应的图中的节点</span></span><br><span class="line">    <span class="comment">#默认值为&#x27;all_filters&#x27;, 可选值为&#x27;no_filter&#x27;, &#x27;no_stop_words&#x27;, &#x27;all_filters&#x27;</span></span><br><span class="line">    <span class="comment"># edge_source: 选择使用words_no_filter, words_no_stop_words, words_all_filters中的哪&gt;一个来构造pagerank对应的图中的节点之间的边</span></span><br><span class="line">    <span class="comment">#默认值为&#x27;no_stop_words&#x27;, 可选值为&#x27;no_filter&#x27;, &#x27;no_stop_words&#x27;, &#x27;all_filters&#x27;, 边的构造要结合window参数</span></span><br><span class="line">    <span class="comment"># pagerank_config: pagerank算法参数配置, 阻尼系数为0.85</span></span><br><span class="line"></span><br><span class="line">    tr4w.analyze(text=text, window=<span class="number">2</span>, lower=<span class="literal">True</span>, vertex_source=<span class="string">&#x27;all_filters&#x27;</span>,</span><br><span class="line">                 edge_source=<span class="string">&#x27;no_stop_words&#x27;</span>, pagerank_config=&#123;<span class="string">&#x27;alpha&#x27;</span>: <span class="number">0.85</span>, &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># num: 返回关键词数量</span></span><br><span class="line">    <span class="comment"># word_min_len: 词的最小长度, 默认值为1    </span></span><br><span class="line">    keywords = tr4w.get_keywords(num=<span class="number">6</span>, word_min_len=<span class="number">2</span>)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"> <span class="comment">#提取重要关键短句</span></span><br><span class="line">    <span class="comment"># keywords_num: 抽取的关键词数量</span></span><br><span class="line">    <span class="comment"># min_occur_num: 关键短语在文中的最少出现次数</span></span><br><span class="line">    <span class="comment">#keyphrases = tr4w.get_keyphrases(keywords_num=6, min_occur_num=1)</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">#提取关键句</span></span><br><span class="line">    <span class="comment">#tr4s = TextRank4Sentence()</span></span><br><span class="line">        <span class="comment"># text: 文本内容, 字符串</span></span><br><span class="line">    <span class="comment"># lower: 是否将英文文本转换为小写, 默认值为False</span></span><br><span class="line">    <span class="comment"># source: 选择使用words_no_filter, words_no_stop_words, words_all_filters中的哪一个来生成句子之间的相似度</span></span><br><span class="line">    <span class="comment">#默认值为&#x27;all_filters&#x27;, 可选值为&#x27;no_filter&#x27;, &#x27;no_stop_words&#x27;, &#x27;all_filters&#x27;</span></span><br><span class="line">    <span class="comment">#tr4s.analyze(text, lower=True, source=&#x27;all_filters&#x27;)</span></span><br><span class="line">    <span class="comment"># 获取最重要的num个长度大于等于sentence_min_len的句子用来生成摘要</span></span><br><span class="line">    <span class="comment">#keysentences = tr4s.get_key_sentences(num=3, sentence_min_len=6)</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment"># 返回关键词</span></span><br><span class="line">    <span class="keyword">return</span> keywords</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    text = <span class="string">&quot;来源：中国科学报本报讯（记者肖洁）又有一位中国科学家喜获小行星命名殊荣！4月19日下午，中国科学院国家天文台在京举行“周又元星”颁授仪式，&quot;</span> \</span><br><span class="line">           <span class="string">&quot;我国天文学家、中国科学院院士周又元的弟子与后辈在欢声笑语中济济一堂。国家天文台党委书记、&quot;</span> \</span><br><span class="line">           <span class="string">&quot;副台长赵刚在致辞一开始更是送上白居易的诗句：“令公桃李满天下，何须堂前更种花。”&quot;</span> \</span><br><span class="line">           <span class="string">&quot;据介绍，这颗小行星由国家天文台施密特CCD小行星项目组于1997年9月26日发现于兴隆观测站，&quot;</span> \</span><br><span class="line">           <span class="string">&quot;获得国际永久编号第120730号。2018年9月25日，经国家天文台申报，&quot;</span> \</span><br><span class="line">           <span class="string">&quot;国际天文学联合会小天体联合会小天体命名委员会批准，国际天文学联合会《小行星通报》通知国际社会，&quot;</span> \</span><br><span class="line">           <span class="string">&quot;正式将该小行星命名为“周又元星”。&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#关键词抽取</span></span><br><span class="line">    keywords=keywords_extraction(text)</span><br><span class="line">    <span class="built_in">print</span>(keywords)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="打印：-1"><a href="#打印：-1" class="headerlink" title="打印："></a>打印：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#关键词抽取</span></span><br><span class="line">[&#123;<span class="string">&#x27;word&#x27;</span>: <span class="string">&#x27;小行星&#x27;</span>, <span class="string">&#x27;weight&#x27;</span>: <span class="number">0.05808441467341854</span>&#125;,</span><br><span class="line">&#123;<span class="string">&#x27;word&#x27;</span>: <span class="string">&#x27;天文台&#x27;</span>, <span class="string">&#x27;weight&#x27;</span>: <span class="number">0.05721653775742513</span>&#125;, </span><br><span class="line">&#123;<span class="string">&#x27;word&#x27;</span>: <span class="string">&#x27;命名&#x27;</span>, <span class="string">&#x27;weight&#x27;</span>: <span class="number">0.0485177005159723</span>&#125;,</span><br><span class="line">&#123;<span class="string">&#x27;word&#x27;</span>: <span class="string">&#x27;中国&#x27;</span>, <span class="string">&#x27;weight&#x27;</span>: <span class="number">0.045716478124251815</span>&#125;, </span><br><span class="line">&#123;<span class="string">&#x27;word&#x27;</span>: <span class="string">&#x27;中国科学院&#x27;</span>, <span class="string">&#x27;weight&#x27;</span>: <span class="number">0.037818937836996636</span>&#125;, </span><br><span class="line">&#123;<span class="string">&#x27;word&#x27;</span>: <span class="string">&#x27;国家&#x27;</span>, <span class="string">&#x27;weight&#x27;</span>: <span class="number">0.03438059254484016</span>&#125;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#提取重要关键短句</span></span><br><span class="line">[<span class="string">&#x27;小行星命名&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#提取关键句</span></span><br><span class="line">[&#123;<span class="string">&#x27;index&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;sentence&#x27;</span>: <span class="string">&#x27;2018年9月25日，经国家天文台申报，国际天文学联合会小天体联合会小天体命名委员会批准，国际天文学联合会《小行星通报》通知国际社会，正式将该小行星命名为“周又元星”&#x27;</span>, <span class="string">&#x27;weight&#x27;</span>: <span class="number">0.2281040325096452</span>&#125;,</span><br><span class="line"> &#123;<span class="string">&#x27;index&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;sentence&#x27;</span>: <span class="string">&#x27;”据介绍，这颗小行星由国家天文台施密特CCD小行星项目组于1997年9月26日发现于兴隆观测站，获得国际永久编号第120730号&#x27;</span>, <span class="string">&#x27;weight&#x27;</span>: <span class="number">0.2106246105971721</span>&#125;,</span><br><span class="line"> &#123;<span class="string">&#x27;index&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;sentence&#x27;</span>: <span class="string">&#x27;4月19日下午，中国科学院国家天文台在京举行“周又元星”颁授仪式，我国天文学家、中国科学院院士周又元的弟子与后辈在欢声笑语中济济一堂&#x27;</span>, <span class="string">&#x27;weight&#x27;</span>: <span class="number">0.2020923401661083</span>&#125;]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3-2：基于jieba的TextRank算法"><a href="#3-2：基于jieba的TextRank算法" class="headerlink" title="3.2：基于jieba的TextRank算法"></a>3.2：基于jieba的TextRank算法</h4><ul><li>jieba工具不仅仅可以用来分词, 进行词性分析. 也可以用来完成TextRank.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> jieba.analyse</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">jieba_keywords_textrank</span>(<span class="params">text</span>):</span></span><br><span class="line">    keywords = jieba.analyse.textrank(text, topK=<span class="number">6</span>)</span><br><span class="line">    <span class="keyword">return</span> keywords</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    text = <span class="string">&quot;来源：中国科学报本报讯（记者肖洁）又有一位中国科学家喜获小行星命名殊荣！4月19日下午，中国科学院国家天文台在京举行“周又元星”颁授仪式，&quot;</span> \</span><br><span class="line">           <span class="string">&quot;我国天文学家、中国科学院院士周又元的弟子与后辈在欢声笑语中济济一堂。国家天文台党委书记、&quot;</span> \</span><br><span class="line">           <span class="string">&quot;副台长赵刚在致辞一开始更是送上白居易的诗句：“令公桃李满天下，何须堂前更种花。”&quot;</span> \</span><br><span class="line">           <span class="string">&quot;据介绍，这颗小行星由国家天文台施密特CCD小行星项目组于1997年9月26日发现于兴隆观测站，&quot;</span> \</span><br><span class="line">           <span class="string">&quot;获得国际永久编号第120730号。2018年9月25日，经国家天文台申报，&quot;</span> \</span><br><span class="line">           <span class="string">&quot;国际天文学联合会小天体联合会小天体命名委员会批准，国际天文学联合会《小行星通报》通知国际社会，&quot;</span> \</span><br><span class="line">           <span class="string">&quot;正式将该小行星命名为“周又元星”。&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 基于jieba的textrank算法实现</span></span><br><span class="line">    keywords = jieba_keywords_textrank(text)</span><br><span class="line">    <span class="built_in">print</span>(keywords)</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><h6 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果:"></a>输出结果:</h6></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&#x27;小行星&#x27;</span>, <span class="string">&#x27;命名&#x27;</span>, <span class="string">&#x27;国际&#x27;</span>, <span class="string">&#x27;中国&#x27;</span>, <span class="string">&#x27;国家&#x27;</span>, <span class="string">&#x27;天文学家&#x27;</span>]</span><br></pre></td></tr></table></figure><h2 id="2：-TextRank实现baseline-0模型"><a href="#2：-TextRank实现baseline-0模型" class="headerlink" title="2： TextRank实现baseline-0模型"></a><strong>2： TextRank实现baseline-0模型</strong></h2><h4 id="数据预处理："><a href="#数据预处理：" class="headerlink" title="数据预处理："></a>数据预处理：</h4><ul><li><p>我们在第一章的1.2小节曾经讨论过原始数据存在的各种问题, 这些问题都需要在数据预处理的这个环节一一解决. 接下来按照如下步骤进行处理:</p><ul><li><p>第一步: 提取特定的文本.</p></li><li><p>第二步: 删除”脏”数据.</p></li><li><p>第三步: 删除特定的字符集合.</p></li><li><p>第四步: 删除特殊位置的特定字符.</p></li></ul></li></ul><h4 id="第一步-提取特定的文本"><a href="#第一步-提取特定的文本" class="headerlink" title="第一步: 提取特定的文本."></a>第一步: 提取特定的文本.</h4><p>面对原始语料, 并不是说我们必须要全部纳入模型中, 可以根据业务需求, 或者程序员的项目经验, 或许出于尝试的态度, 只选取一部分出来作为我们后续模型的输入数据.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clean_sentence</span>(<span class="params">sentence</span>):</span></span><br><span class="line">    <span class="comment"># 1. 将sentence按照&#x27;|&#x27;分句，并只提取技师的话</span></span><br><span class="line">    sub_jishi = []</span><br><span class="line">    <span class="comment"># 按照&#x27;|&#x27;字符将车主和用户的对话分离</span></span><br><span class="line">    sub = sentence.split(<span class="string">&#x27;|&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 遍历每个子句</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(sub)):</span><br><span class="line">        <span class="comment"># 如果不是以句号结尾, 增加一个句号</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> sub[i].endswith(<span class="string">&#x27;。&#x27;</span>):</span><br><span class="line">            sub[i] += <span class="string">&#x27;。&#x27;</span></span><br><span class="line">        <span class="comment"># 只使用技师说的句子</span></span><br><span class="line">        <span class="keyword">if</span> sub[i].startswith(<span class="string">&#x27;技师&#x27;</span>):</span><br><span class="line">            sub_jishi.append(sub[i])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 拼接成字符串并返回</span></span><br><span class="line">    sentence = <span class="string">&#x27;&#x27;</span>.join(sub_jishi)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sentence</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 读取数据, 并指定编码格式为&#x27;utf-8&#x27;</span></span><br><span class="line">    df = pd.read_csv(<span class="string">&#x27;train.csv&#x27;</span>, engine=<span class="string">&#x27;python&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    texts = df[<span class="string">&#x27;Dialogue&#x27;</span>].tolist()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;预处理前的第一条句子：&#x27;</span>, texts[<span class="number">0</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;********************************&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 数据预处理</span></span><br><span class="line">    res = clean_sentence(texts[<span class="number">0</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;预处理后的第一条句子: &#x27;</span>, res)</span><br></pre></td></tr></table></figure><ul><li><h6 id="输出结果-1"><a href="#输出结果-1" class="headerlink" title="输出结果:"></a>输出结果:</h6></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">预处理前的第一条句子： 技师说：[语音]|车主说：新的都换了|车主说：助力泵，方向机|技师说：[语音]|车主说：换了方向机带的有|车主说：[图片]|技师说：[语音]|车主说：有助力就是重，这车要匹配吧|技师说：不需要|技师说：你这是更换的部件有问题|车主说：跑快了还好点，就倒车重的很。|技师说：是非常重吗|车主说：是的，累人|技师说：[语音]|车主说：我觉得也是，可是车主是以前没这么重，选吧助理泵换了不行，又把放向机换了，现在还这样就不知道咋和车主解释。|技师说：[语音]|技师说：[语音]</span><br><span class="line"></span><br><span class="line">预处理后的第一条句子:  技师说：[语音]。技师说：[语音]。技师说：[语音]。技师说：不需要。技师说：你这是更换的部件有问题。技师说：是非常重吗。技师说：[语音]。技师说：[语音]。技师说：[语音]。</span><br></pre></td></tr></table></figure><ul><li><h5 id="数据进行分割形成小型数据"><a href="#数据进行分割形成小型数据" class="headerlink" title="数据进行分割形成小型数据"></a>数据进行分割形成小型数据</h5></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nf = df[:<span class="number">5000</span>]</span><br><span class="line">nf.to_csv(<span class="string">&quot;dev.csv&quot;</span>,mode=<span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">dfa  = pd.read_csv(<span class="string">&quot;dev.csv&quot;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">dfa.head()</span><br></pre></td></tr></table></figure><p>打印结果</p><p><img src="C:\Users\86176\MyBlog\source_posts\tupian\1623239367253.png" alt="1623239367253"></p><h4 id="第二步-删除”脏”数据"><a href="#第二步-删除”脏”数据" class="headerlink" title="第二步: 删除”脏”数据."></a>第二步: 删除”脏”数据.</h4><ul><li>关于什么是”脏”数据是个千人千面的问题, 我们在第一章中也讨论过. 这一步也仅仅处理一个baseline的级别.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入正则表达式工具包, 用来删除特定模式的数据</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clean_sentence</span>(<span class="params">sentence</span>):</span></span><br><span class="line">    <span class="comment"># 1. 将sentence按照&#x27;|&#x27;分句，并只提取技师的话</span></span><br><span class="line">    sub_jishi = []</span><br><span class="line">    <span class="comment"># 按照&#x27;|&#x27;字符将车主和用户的对话分离</span></span><br><span class="line">    sub = sentence.split(<span class="string">&#x27;|&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 遍历每个子句</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(sub)):</span><br><span class="line">        <span class="comment"># 如果不是以句号结尾, 增加一个句号</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> sub[i].endswith(<span class="string">&#x27;。&#x27;</span>):</span><br><span class="line">            sub[i] += <span class="string">&#x27;。&#x27;</span></span><br><span class="line">        <span class="comment"># 只使用技师说的句子</span></span><br><span class="line">        <span class="keyword">if</span> sub[i].startswith(<span class="string">&#x27;技师&#x27;</span>):</span><br><span class="line">            sub_jishi.append(sub[i])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 拼接成字符串并返回</span></span><br><span class="line">    sentence = <span class="string">&#x27;&#x27;</span>.join(sub_jishi)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 第二步中添加的两个处理, 利用正则表达式re工具</span></span><br><span class="line">    <span class="comment"># 2. 删除1. 2. 3. 这些标题</span></span><br><span class="line">    r = re.<span class="built_in">compile</span>(<span class="string">&quot;\D(\d\.)\D&quot;</span>)</span><br><span class="line">    sentence = r.sub(<span class="string">&quot;&quot;</span>, sentence)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3. 删除一些无关紧要的词以及语气助词</span></span><br><span class="line">    r = re.<span class="built_in">compile</span>(<span class="string">r&quot;车主说|技师说|语音|图片|呢|吧|哈|啊|啦&quot;</span>)</span><br><span class="line">    sentence = r.sub(<span class="string">&quot;&quot;</span>, sentence)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sentence</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 读取数据, 并指定编码格式为&#x27;utf-8&#x27;</span></span><br><span class="line">    df = pd.read_csv(<span class="string">&#x27;dev.csv&#x27;</span>, engine=<span class="string">&#x27;python&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    texts = df[<span class="string">&#x27;Dialogue&#x27;</span>].tolist()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;预处理前的第一条句子：&#x27;</span>, texts[<span class="number">0</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;********************************&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 数据预处理</span></span><br><span class="line">    res = clean_sentence(texts[<span class="number">0</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;预处理后的第一条句子: &#x27;</span>, res)</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><h5 id="处理后的数据"><a href="#处理后的数据" class="headerlink" title="处理后的数据"></a>处理后的数据</h5></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">预处理前的第一条句子： 技师说：[语音]|车主说：新的都换了|车主说：助力泵，方向机|技师说：[语音]|车主说：换了方向机带的有|车主说：[图片]|技师说：[语音]|车主说：有助力就是重，这车要匹配吧|技师说：不需要|技师说：你这是更换的部件有问题|车主说：跑快了还好点，就倒车重的很。|技师说：是非常重吗|车主说：是的，累人|技师说：[语音]|车主说：我觉得也是，可是车主是以前没这么重，选吧助理泵换了不行，又把放向机换了，现在还这样就不知道咋和车主解释。|技师说：[语音]|技师说：[语音]</span><br><span class="line"></span><br><span class="line">预处理后的第一条句子:  ：[]。：[]。：[]。：不需要。：你这是更换的部件有问题。：是非常重吗。：[]。：[]。：[]</span><br></pre></td></tr></table></figure><h4 id="第三步-删除特定的字符集合"><a href="#第三步-删除特定的字符集合" class="headerlink" title="第三步: 删除特定的字符集合."></a>第三步: 删除特定的字符集合.</h4><ul><li>1: 我们发现原始数据文件中有若干的”进口”, “海外”字样, 可认为是需要删除的特定字符.</li><li>2: 为了后续处理文本容易, 除了汉字还有数字, 英文字母, 特定的几个标点符号, 其他都删除.</li><li>3: 将标点符号的半角格式, 转变成全角格式.</li><li>4: 将问号, 感叹号, 转变成句号.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入正则表达式工具包, 用来删除特定模式的数据</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clean_sentence</span>(<span class="params">sentence</span>):</span></span><br><span class="line">    <span class="comment"># 第一步要处理的代码</span></span><br><span class="line">    <span class="comment"># 1. 将sentence按照&#x27;|&#x27;分句，并只提取技师的话</span></span><br><span class="line">    sub_jishi = []</span><br><span class="line">    <span class="comment"># 按照&#x27;|&#x27;字符将车主和用户的对话分离</span></span><br><span class="line">    sub = sentence.split(<span class="string">&#x27;|&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 遍历每个子句</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(sub)):</span><br><span class="line">        <span class="comment"># 如果不是以句号结尾, 增加一个句号</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> sub[i].endswith(<span class="string">&#x27;。&#x27;</span>):</span><br><span class="line">            sub[i] += <span class="string">&#x27;。&#x27;</span></span><br><span class="line">        <span class="comment"># 只使用技师说的句子</span></span><br><span class="line">        <span class="keyword">if</span> sub[i].startswith(<span class="string">&#x27;技师&#x27;</span>):</span><br><span class="line">            sub_jishi.append(sub[i])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 拼接成字符串并返回</span></span><br><span class="line">    sentence = <span class="string">&#x27;&#x27;</span>.join(sub_jishi)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 第二步中添加的两个处理, 利用正则表达式re工具</span></span><br><span class="line">    <span class="comment"># 2. 删除1. 2. 3. 这些标题</span></span><br><span class="line">    r = re.<span class="built_in">compile</span>(<span class="string">&quot;\D(\d\.)\D&quot;</span>)</span><br><span class="line">    sentence = r.sub(<span class="string">&quot;&quot;</span>, sentence)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3. 删除一些无关紧要的词以及语气助词</span></span><br><span class="line">    r = re.<span class="built_in">compile</span>(<span class="string">r&quot;车主说|技师说|语音|图片|呢|吧|哈|啊|啦&quot;</span>)</span><br><span class="line">    sentence = r.sub(<span class="string">&quot;&quot;</span>, sentence)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 第三步中添加的4个处理</span></span><br><span class="line">    <span class="comment"># 4. 删除带括号的 进口 海外</span></span><br><span class="line">    r = re.<span class="built_in">compile</span>(<span class="string">r&quot;[(（]进口[)）]|\(海外\)&quot;</span>)</span><br><span class="line">    sentence = r.sub(<span class="string">&quot;&quot;</span>, sentence)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 5. 删除除了汉字数字字母和，！？。.- 以外的字符</span></span><br><span class="line">    r = re.<span class="built_in">compile</span>(<span class="string">&quot;[^，！？。\.\-\u4e00-\u9fa5_a-zA-Z0-9]&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 6. 半角变为全角</span></span><br><span class="line">    sentence = sentence.replace(<span class="string">&quot;,&quot;</span>, <span class="string">&quot;，&quot;</span>)</span><br><span class="line">    sentence = sentence.replace(<span class="string">&quot;!&quot;</span>, <span class="string">&quot;！&quot;</span>)</span><br><span class="line">    sentence = sentence.replace(<span class="string">&quot;?&quot;</span>, <span class="string">&quot;？&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 7. 问号叹号变为句号</span></span><br><span class="line">    sentence = sentence.replace(<span class="string">&quot;？&quot;</span>, <span class="string">&quot;。&quot;</span>)</span><br><span class="line">    sentence = sentence.replace(<span class="string">&quot;！&quot;</span>, <span class="string">&quot;。&quot;</span>)</span><br><span class="line">    sentence = r.sub(<span class="string">&quot;&quot;</span>, sentence)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 第四步添加的删除特定位置的特定字符</span></span><br><span class="line">    <span class="comment"># 8. 删除句子开头的逗号</span></span><br><span class="line">    <span class="keyword">if</span> sentence.startswith(<span class="string">&#x27;，&#x27;</span>):</span><br><span class="line">        sentence = sentence[<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sentence</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 读取数据, 并指定编码格式为&#x27;utf-8&#x27;</span></span><br><span class="line">    df = pd.read_csv(<span class="string">&#x27;dev.csv&#x27;</span>, engine=<span class="string">&#x27;python&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    texts = df[<span class="string">&#x27;Dialogue&#x27;</span>].tolist()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;预处理前的第一条句子：&#x27;</span>, texts[<span class="number">0</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;********************************&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 数据预处理</span></span><br><span class="line">    res = clean_sentence(texts[<span class="number">0</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;预处理后的第一条句子: &#x27;</span>, res)</span><br></pre></td></tr></table></figure><h5 id="打印操作"><a href="#打印操作" class="headerlink" title="打印操作"></a>打印操作</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">预处理前的第一条句子： 技师说：[语音]|车主说：新的都换了|车主说：助力泵，方向机|技师说：[语音]|车主说：换了方向机带的有|车主说：[图片]|技师说：[语音]|车主说：有助力就是重，这车要匹配吧|技师说：不需要|技师说：你这是更换的部件有问题|车主说：跑快了还好点，就倒车重的很。|技师说：是非常重吗|车主说：是的，累人|技师说：[语音]|车主说：我觉得也是，可是车主是以前没这么重，选吧助理泵换了不行，又把放向机换了，现在还这样就不知道咋和车主解释。|技师说：[语音]|技师说：[语音]</span><br><span class="line"></span><br><span class="line">预处理后的第一条句子:  。。。不需要。你这是更换的部件有问题。是非常重吗。。。。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-1：TextRank模型代码实现：进行数数的机器学习模型"><a href="#2-1：TextRank模型代码实现：进行数数的机器学习模型" class="headerlink" title="2.1：TextRank模型代码实现：进行数数的机器学习模型"></a>2.1：TextRank模型代码实现：进行数数的机器学习模型</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入正则表达式工具包, 用来删除特定模式的数据</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clean_sentence</span>(<span class="params">sentence</span>):</span></span><br><span class="line">    <span class="comment"># 第一步要处理的代码</span></span><br><span class="line">    <span class="comment"># 1. 将sentence按照&#x27;|&#x27;分句，并只提取技师的话</span></span><br><span class="line">    sub_jishi = []</span><br><span class="line">    <span class="comment"># 按照&#x27;|&#x27;字符将车主和用户的对话分离</span></span><br><span class="line">    sub = sentence.split(<span class="string">&#x27;|&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 遍历每个子句</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(sub)):</span><br><span class="line">        <span class="comment"># 如果不是以句号结尾, 增加一个句号</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> sub[i].endswith(<span class="string">&#x27;。&#x27;</span>):</span><br><span class="line">            sub[i] += <span class="string">&#x27;。&#x27;</span></span><br><span class="line">        <span class="comment"># 只使用技师说的句子</span></span><br><span class="line">        <span class="keyword">if</span> sub[i].startswith(<span class="string">&#x27;技师&#x27;</span>):</span><br><span class="line">            sub_jishi.append(sub[i])</span><br><span class="line">    <span class="comment"># 拼接成字符串并返回</span></span><br><span class="line">    sentence = <span class="string">&#x27;&#x27;</span>.join(sub_jishi)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 第二步中添加的两个处理, 利用正则表达式re工具</span></span><br><span class="line">    <span class="comment"># 2. 删除1. 2. 3. 这些标题</span></span><br><span class="line">    r = re.<span class="built_in">compile</span>(<span class="string">&quot;\D(\d\.)\D&quot;</span>)</span><br><span class="line">    sentence = r.sub(<span class="string">&quot;&quot;</span>, sentence)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3. 删除一些无关紧要的词以及语气助词</span></span><br><span class="line">    r = re.<span class="built_in">compile</span>(<span class="string">r&quot;车主说|技师说|语音|图片|呢|吧|哈|啊|啦&quot;</span>)</span><br><span class="line">    sentence = r.sub(<span class="string">&quot;&quot;</span>, sentence)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 第三步中添加的4个处理</span></span><br><span class="line">    <span class="comment"># 4. 删除带括号的 进口 海外</span></span><br><span class="line">    r = re.<span class="built_in">compile</span>(<span class="string">r&quot;[(（]进口[)）]|\(海外\)&quot;</span>)</span><br><span class="line">    sentence = r.sub(<span class="string">&quot;&quot;</span>, sentence)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 5. 删除除了汉字数字字母和，！？。.- 以外的字符</span></span><br><span class="line">    r = re.<span class="built_in">compile</span>(<span class="string">&quot;[^，！？。\.\-\u4e00-\u9fa5_a-zA-Z0-9]&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 6. 半角变为全角</span></span><br><span class="line">    sentence = sentence.replace(<span class="string">&quot;,&quot;</span>, <span class="string">&quot;，&quot;</span>)</span><br><span class="line">    sentence = sentence.replace(<span class="string">&quot;!&quot;</span>, <span class="string">&quot;！&quot;</span>)</span><br><span class="line">    sentence = sentence.replace(<span class="string">&quot;?&quot;</span>, <span class="string">&quot;？&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 7. 问号叹号变为句号</span></span><br><span class="line">    sentence = sentence.replace(<span class="string">&quot;？&quot;</span>, <span class="string">&quot;。&quot;</span>)</span><br><span class="line">    sentence = sentence.replace(<span class="string">&quot;！&quot;</span>, <span class="string">&quot;。&quot;</span>)</span><br><span class="line">    sentence = r.sub(<span class="string">&quot;&quot;</span>, sentence)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 第四步添加的删除特定位置的特定字符</span></span><br><span class="line">    <span class="comment"># 8. 删除句子开头的逗号</span></span><br><span class="line">    <span class="keyword">if</span> sentence.startswith(<span class="string">&#x27;，&#x27;</span>):</span><br><span class="line">        sentence = sentence[<span class="number">1</span>:]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sentence</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 读取数据, 并指定编码格式为&#x27;utf-8&#x27;</span></span><br><span class="line">    df = pd.read_csv(<span class="string">&#x27;dev.csv&#x27;</span>, engine=<span class="string">&#x27;python&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    texts = df[<span class="string">&#x27;Dialogue&#x27;</span>].tolist()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(texts)):</span><br><span class="line">        texts[i] = clean_sentence(texts[i])</span><br><span class="line">        <span class="keyword">if</span> i % <span class="number">500</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;i=&quot;</span>,i)</span><br><span class="line">        <span class="comment"># 初始化结果存放的列表</span></span><br><span class="line">    results = []</span><br><span class="line">    <span class="comment"># 初始化textrank4zh类对象</span></span><br><span class="line">    tr4s = TextRank4Sentence()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(texts)):</span><br><span class="line">        text = texts[i]</span><br><span class="line">        tr4s.analyze(text = text,lower = <span class="literal">True</span>,source = <span class="string">&quot;all_filters&quot;</span>)</span><br><span class="line">        result = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 直接调用函数获取关键语句</span></span><br><span class="line">        <span class="comment"># num=3: 获取重要性最高的3个句子.</span></span><br><span class="line">        <span class="comment"># sentence_min_len=2: 句子的长度最小等于2.</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> tr4s.get_key_sentences(num=<span class="number">3</span>, sentence_min_len=<span class="number">2</span>):</span><br><span class="line">            result += item.sentence</span><br><span class="line">            result += <span class="string">&#x27;。&#x27;</span></span><br><span class="line">        results.append(result)</span><br><span class="line">        <span class="comment"># 间隔100次打印结果</span></span><br><span class="line">        <span class="keyword">if</span> (i + <span class="number">1</span>) % <span class="number">100</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(i + <span class="number">1</span>, result)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;result length: &#x27;</span>, <span class="built_in">len</span>(results))</span><br><span class="line">    <span class="comment"># 保存结果</span></span><br><span class="line">    df[<span class="string">&#x27;Prediction&#x27;</span>] = results</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 提取ID, Report, 和预测结果这3列</span></span><br><span class="line">    df = df[[<span class="string">&#x27;QID&#x27;</span>, <span class="string">&#x27;Report&#x27;</span>, <span class="string">&#x27;Prediction&#x27;</span>]]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 保存结果，这里自动生成一个结果名</span></span><br><span class="line">    df.to_csv(<span class="string">&#x27;textrank_result_.csv&#x27;</span>, index=<span class="literal">None</span>, sep=<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将空行置换为随时联系, 文件保存格式指定为utf-8</span></span><br><span class="line">    df = pd.read_csv(<span class="string">&#x27;textrank_result_.csv&#x27;</span>, engine=<span class="string">&#x27;python&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    df = df.fillna(<span class="string">&#x27;随时联系。&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将处理后的文件保存起来</span></span><br><span class="line">    df.to_csv(<span class="string">&#x27;textrank_result_final_.csv&#x27;</span>, index=<span class="literal">None</span>, sep=<span class="string">&#x27;,&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>打印结果</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">i= <span class="number">0</span></span><br><span class="line">i= <span class="number">500</span></span><br><span class="line">i= <span class="number">1000</span></span><br><span class="line">i= <span class="number">1500</span></span><br><span class="line">i= <span class="number">2000</span></span><br><span class="line">i= <span class="number">2500</span></span><br><span class="line">i= <span class="number">3000</span></span><br><span class="line">i= <span class="number">3500</span></span><br><span class="line">i= <span class="number">4000</span></span><br><span class="line">i= <span class="number">4500</span></span><br><span class="line"><span class="number">100</span> 这个故障一般是转向系统的故障，需要重点检查一下车辆的转向灯泡，是否有不亮的。换了就可以解决问题。你好，车辆故障信息代码标识。</span><br><span class="line"><span class="number">200</span> 主要是找到发动机和变速器连接部位的支架以及底盘上的各个胶套，是否存在松旷，造成硬性的接触共振。你好，这种情况主要考虑检查底盘是否存在共振区域。这个需要全面检查，如果之前没有这种问题，可以试驾其他同款车辆，确认是否都有这种问题。</span><br><span class="line"><span class="number">300</span> 您好出厂的时候变速箱油是正常的，在刻度线以内，流出半升之后还是在刻度线以内，所以不用加，亲。加不进去了。顶进去的。</span><br><span class="line"><span class="number">400</span> 那就要去检查一下皮带轮了。如果高于<span class="number">1200</span>还有，就要检查一下皮带轮。这款发动机在<span class="number">900</span>-<span class="number">1100</span>转时确实有一点嗡嗡声。</span><br><span class="line"><span class="number">500</span> 这种单边积水的情况基本上不是泡水的原因，而是有地方密封不严，下雨漏水进去，这个一般是门边密封条老化，或者是防风玻璃漏水，需要关上车门，在车外冲水，在车内慢慢找漏水的地方。海绵积水可以用洗车的泡沫海绵放在上面挤压，能把大部的水吸出来，然后大太阳的时候打开车门得晒一个星期左右，差不多就会干了，主要还是得找出进水的原因，不然弄干水了，下次又进水了，时间长了，海绵会发霉发臭的。我知道是地板上积水，空调管堵塞也是会造成这种情况的，也是需要检查的。</span><br><span class="line"><span class="number">600</span> 您好，需要更换加油管和碳罐，加油时气体排不出去导致跳枪。估计外面找不到改款配件。加油管是改款双管的，原车是单管的。</span><br><span class="line"><span class="number">700</span> 找领导处理，更换新件并赔偿。送保养次数。投诉厂家，欺骗消费者。</span><br><span class="line"><span class="number">800</span> 用T10170和百分表，转曲轴看百分表指针，指针转到顺时针的最顶端是一缸上止点。把曲轴转到一缸上止点，然后挂链条就可以了。直接量一缸的上止点不就可以了，不用管其他缸。</span><br></pre></td></tr></table></figure><h1 id="3：-seq2seq实现baseline-1模型：文本摘要"><a href="#3：-seq2seq实现baseline-1模型：文本摘要" class="headerlink" title="3： seq2seq实现baseline-1模型：文本摘要"></a>3： seq2seq实现baseline-1模型：文本摘要</h1><h3 id="seq2seq实现文本摘要的架构"><a href="#seq2seq实现文本摘要的架构" class="headerlink" title="seq2seq实现文本摘要的架构"></a>seq2seq实现文本摘要的架构</h3><ul><li>首选回顾一下在英译法任务中的经典seq2seq架构图</li></ul><p><img src="C:\Users\86176\MyBlog\source_posts\tupian\1623239860981.png" alt="1623239860981"></p><blockquote><ul><li>编码器端负责将输入数据进行编码, 得到中间语义张量.</li><li>解码器端负责一次次的循环解析中间语义张量, 得到最终的结果语句.</li><li>一般来说, 我们将注意力机制添加在解码器端.</li></ul></blockquote><h4 id="对比于英译法任务-我们再来看文本摘要任务下的seq2seq架构图"><a href="#对比于英译法任务-我们再来看文本摘要任务下的seq2seq架构图" class="headerlink" title="对比于英译法任务, 我们再来看文本摘要任务下的seq2seq架构图:"></a>对比于英译法任务, 我们再来看文本摘要任务下的seq2seq架构图:</h4><p><img src="C:\Users\86176\MyBlog\source_posts\tupian\1623241168701.png" alt="1623241168701"></p><blockquote><ul><li>编码器端负责进行原始文本的编码.</li><li>注意力层结合编码张量和解码器端的当前输入, 得到总体上的内容张量.</li><li>最后在注意力机制的指导下, 解码器端得到完整的单词分布, 解码出当前时间步的单词.</li></ul></blockquote><h3 id="seq2seq实现文本摘要的架构代码实践"><a href="#seq2seq实现文本摘要的架构代码实践" class="headerlink" title="seq2seq实现文本摘要的架构代码实践"></a>seq2seq实现文本摘要的架构代码实践</h3><h4 id="若干工具函数的实现"><a href="#若干工具函数的实现" class="headerlink" title="若干工具函数的实现"></a>若干工具函数的实现</h4><ul><li><p>在这一部分中我们要实现如下几个工具函数:</p><ul><li>第一步: 实现配置函数config.py</li><li>第二步: 实现多核并行处理的函数multi_proc_utils.py</li><li>第三步: 实现参数配置函数params_utils.py</li><li>第四步: 实现保存字典的函数word2vec_utils.py</li><li>第五步: 实现数据加载的函数data_loader.py</li></ul></li><li><h4 id="第一步-实现配置函数config-py"><a href="#第一步-实现配置函数config-py" class="headerlink" title="第一步: 实现配置函数config.py"></a>第一步: 实现配置函数config.py</h4><ul><li>代码文件路径: /home/ec2-user/text_summary/seq2seq/utils/config.py</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入os工具包</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置项目代码库的root路径, 为后续所有的包导入提供便利</span></span><br><span class="line">root_path = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))</span><br><span class="line">sys.path.append(root_path)</span><br><span class="line"><span class="built_in">print</span>(root_path)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置原始数据文件的路径, 通过以项目root路径为基础, 逐级添加到文件路径</span></span><br><span class="line">train_raw_data_path = os.path.join(root_path, <span class="string">&#x27;data&#x27;</span>, <span class="string">&#x27;train.csv&#x27;</span>)</span><br><span class="line">test_raw_data_path = os.path.join(root_path, <span class="string">&#x27;data&#x27;</span>, <span class="string">&#x27;test.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停用词路径和jieba分词用户自定义字典路径</span></span><br><span class="line">stop_words_path = os.path.join(root_path, <span class="string">&#x27;data&#x27;</span>, <span class="string">&#x27;stopwords.txt&#x27;</span>)</span><br><span class="line">user_dict_path = os.path.join(root_path, <span class="string">&#x27;data&#x27;</span>, <span class="string">&#x27;user_dict.txt&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 预处理+切分后的训练测试数据路径</span></span><br><span class="line">train_seg_path = os.path.join(root_path, <span class="string">&#x27;data&#x27;</span>, <span class="string">&#x27;train_seg_data.csv&#x27;</span>)</span><br><span class="line">test_seg_path = os.path.join(root_path, <span class="string">&#x27;data&#x27;</span>, <span class="string">&#x27;test_seg_data.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将训练集和测试机数据混合后的文件路径</span></span><br><span class="line">merged_seg_path = os.path.join(root_path, <span class="string">&#x27;data&#x27;</span>, <span class="string">&#x27;merged_seg_data.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 样本与标签分离，并经过pad处理后的数据路径</span></span><br><span class="line">train_x_pad_path = os.path.join(root_path, <span class="string">&#x27;data&#x27;</span>, <span class="string">&#x27;train_X_pad_data.csv&#x27;</span>)</span><br><span class="line">train_y_pad_path = os.path.join(root_path, <span class="string">&#x27;data&#x27;</span>, <span class="string">&#x27;train_Y_pad_data.csv&#x27;</span>)</span><br><span class="line">test_x_pad_path = os.path.join(root_path, <span class="string">&#x27;data&#x27;</span>, <span class="string">&#x27;test_X_pad_data.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># numpy转换为数字后最终使用的的数据路径</span></span><br><span class="line">train_x_path = os.path.join(root_path, <span class="string">&#x27;data&#x27;</span>, <span class="string">&#x27;train_X.npy&#x27;</span>)</span><br><span class="line">train_y_path = os.path.join(root_path, <span class="string">&#x27;data&#x27;</span>, <span class="string">&#x27;train_Y.npy&#x27;</span>)</span><br><span class="line">test_x_path = os.path.join(root_path, <span class="string">&#x27;data&#x27;</span>, <span class="string">&#x27;test_X.npy&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 正向词典和反向词典路径</span></span><br><span class="line">vocab_path = os.path.join(root_path, <span class="string">&#x27;data&#x27;</span>, <span class="string">&#x27;wv&#x27;</span>, <span class="string">&#x27;vocab.txt&#x27;</span>)</span><br><span class="line">reverse_vocab_path = os.path.join(root_path, <span class="string">&#x27;data&#x27;</span>, <span class="string">&#x27;wv&#x27;</span>, <span class="string">&#x27;reverse_vocab.txt&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试集结果保存路径</span></span><br><span class="line">result_save_path = os.path.join(root_path, <span class="string">&#x27;data&#x27;</span>, <span class="string">&#x27;result&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li>输出结果:</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/home/ec2-user/text_summary/seq2seq</span><br></pre></td></tr></table></figure><h4 id="第二步-实现多核并行处理的函数multi-proc-utils-py"><a href="#第二步-实现多核并行处理的函数multi-proc-utils-py" class="headerlink" title="第二步: 实现多核并行处理的函数multi_proc_utils.py"></a>第二步: 实现多核并行处理的函数multi_proc_utils.py</h4><ul><li>代码文件路径: /home/ec2-user/text_summary/seq2seq/utils/multi_proc_utils.py</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> cpu_count, Pool</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算当前服务器CPU的数量</span></span><br><span class="line">cores = cpu_count()</span><br><span class="line"><span class="comment"># 将分块个数设置为CPU的数量</span></span><br><span class="line">partitions = cores</span><br><span class="line"><span class="built_in">print</span>(cores)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parallelize</span>(<span class="params">df, func</span>):</span></span><br><span class="line">    <span class="comment"># 数据切分</span></span><br><span class="line">    data_split = np.array_split(df, partitions)</span><br><span class="line">    <span class="comment"># 初始化线程池</span></span><br><span class="line">    pool = Pool(cores)</span><br><span class="line">    <span class="comment"># 数据分发, 处理, 再合并</span></span><br><span class="line">    data = pd.concat(pool.<span class="built_in">map</span>(func, data_split))</span><br><span class="line">    <span class="comment"># 关闭线程池</span></span><br><span class="line">    pool.close()</span><br><span class="line">    <span class="comment"># 执行完close后不会有新的进程加入到pool, join函数等待所有子进程结束</span></span><br><span class="line">    pool.join()</span><br><span class="line">    <span class="comment"># 返回处理后的数据</span></span><br><span class="line">    <span class="keyword">return</span> data</span><br></pre></td></tr></table></figure><ul><li>输出结果:</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当前服务器是一个8核CPU, 32GB内存的机器</span></span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure><h4 id="第三步-实现参数配置函数params-utils-py"><a href="#第三步-实现参数配置函数params-utils-py" class="headerlink" title="第三步: 实现参数配置函数params_utils.py"></a>第三步: 实现参数配置函数params_utils.py</h4><ul><li>代码文件路径: /home/ec2-user/text_summary/seq2seq/utils/params_utils.py</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_params</span>():</span></span><br><span class="line">    parser = argparse.ArgumentParser()</span><br><span class="line">    <span class="comment"># 编码器和解码器的最大序列长度</span></span><br><span class="line">    parser.add_argument(<span class="string">&quot;--max_enc_len&quot;</span>, default=<span class="number">300</span>, <span class="built_in">help</span>=<span class="string">&quot;Encoder input max sequence length&quot;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&quot;--max_dec_len&quot;</span>, default=<span class="number">50</span>, <span class="built_in">help</span>=<span class="string">&quot;Decoder input max sequence length&quot;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>)</span><br><span class="line">    <span class="comment"># 一个训练批次的大小</span></span><br><span class="line">    parser.add_argument(<span class="string">&quot;--batch_size&quot;</span>, default=<span class="number">64</span>, <span class="built_in">help</span>=<span class="string">&quot;Batch size&quot;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>)</span><br><span class="line">    <span class="comment"># seq2seq训练轮数</span></span><br><span class="line">    parser.add_argument(<span class="string">&quot;--seq2seq_train_epochs&quot;</span>, default=<span class="number">20</span>, <span class="built_in">help</span>=<span class="string">&quot;Seq2seq model training epochs&quot;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>)</span><br><span class="line">    <span class="comment"># 词嵌入大小</span></span><br><span class="line">    parser.add_argument(<span class="string">&quot;--embed_size&quot;</span>, default=<span class="number">500</span>, <span class="built_in">help</span>=<span class="string">&quot;Words embeddings dimension&quot;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>)</span><br><span class="line">    <span class="comment"># 编码器、解码器以及attention的隐含层单元数</span></span><br><span class="line">    parser.add_argument(<span class="string">&quot;--enc_units&quot;</span>, default=<span class="number">512</span>, <span class="built_in">help</span>=<span class="string">&quot;Encoder GRU cell units number&quot;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&quot;--dec_units&quot;</span>, default=<span class="number">512</span>, <span class="built_in">help</span>=<span class="string">&quot;Decoder GRU cell units number&quot;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&quot;--attn_units&quot;</span>, default=<span class="number">20</span>, <span class="built_in">help</span>=<span class="string">&quot;Used to compute the attention weights&quot;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>)</span><br><span class="line">    <span class="comment"># 学习率</span></span><br><span class="line">    parser.add_argument(<span class="string">&quot;--learning_rate&quot;</span>, default=<span class="number">0.001</span>, <span class="built_in">help</span>=<span class="string">&quot;Learning rate&quot;</span>, <span class="built_in">type</span>=<span class="built_in">float</span>)</span><br><span class="line">    args = parser.parse_args()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># param是一个字典类型的变量，键为参数名，值为参数值</span></span><br><span class="line">    params = <span class="built_in">vars</span>(args)</span><br><span class="line">    <span class="keyword">return</span> params</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    res = get_params()</span><br><span class="line">    <span class="built_in">print</span>(res)</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>输出结果:</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;max_enc_len&#x27;</span>: <span class="number">300</span>, <span class="string">&#x27;max_dec_len&#x27;</span>: <span class="number">50</span>, <span class="string">&#x27;batch_size&#x27;</span>: <span class="number">64</span>, <span class="string">&#x27;seq2seq_train_epochs&#x27;</span>: </span><br></pre></td></tr></table></figure><h4 id="第四步-实现保存字典的函数word2vec-utils-py"><a href="#第四步-实现保存字典的函数word2vec-utils-py" class="headerlink" title="第四步: 实现保存字典的函数word2vec_utils.py"></a>第四步: 实现保存字典的函数word2vec_utils.py</h4><ul><li>代码文件路径: /home/ec2-user/text_summary/seq2seq/utils/word2vec_utils.py</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> gensim.models.word2vec <span class="keyword">import</span> Word2Vec</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_embedding_matrix_from_model</span>(<span class="params">wv_model_path</span>):</span></span><br><span class="line">    <span class="comment"># 从word2vec模型中获取词向量矩阵</span></span><br><span class="line">    <span class="comment"># wv_model_path: word2vec模型的路径</span></span><br><span class="line">    wv_model = Word2Vec.load(wv_model_path)</span><br><span class="line">    <span class="comment"># wv_model.wv.vectors包含词向量矩阵</span></span><br><span class="line">    embedding_matrix = wv_model.wv.vectors</span><br><span class="line">    <span class="keyword">return</span> embedding_matrix</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_vocab_from_model</span>(<span class="params">wv_model_path</span>):</span></span><br><span class="line">    <span class="comment"># 从word2vec模型中获取正向和反向词典</span></span><br><span class="line">    <span class="comment"># wv_model_path: word2vec模型的路径</span></span><br><span class="line">    wv_model = Word2Vec.load(wv_model_path)</span><br><span class="line">    id_to_word = &#123;index: word <span class="keyword">for</span> index, word <span class="keyword">in</span> <span class="built_in">enumerate</span>(wv_model.wv.index2word)&#125;</span><br><span class="line">    word_to_id = &#123;word: index <span class="keyword">for</span> index, word <span class="keyword">in</span> <span class="built_in">enumerate</span>(wv_model.wv.index2word)&#125;</span><br><span class="line">    <span class="keyword">return</span> word_to_id, id_to_word</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save_vocab_as_txt</span>(<span class="params">filename, word_to_id</span>):</span></span><br><span class="line">    <span class="comment"># 保存字典</span></span><br><span class="line">    <span class="comment"># filename: 目标txt文件路径</span></span><br><span class="line">    <span class="comment"># word_to_id: 要保存的字典</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> word_to_id.items():</span><br><span class="line">            f.write(<span class="string">&quot;&#123;&#125;\t&#123;&#125;\n&quot;</span>.<span class="built_in">format</span>(k, v))</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1：文本摘要项目理论&quot;&gt;&lt;a href=&quot;#1：文本摘要项目理论&quot; class=&quot;headerlink&quot; title=&quot;1：文本摘要项目理论&quot;&gt;&lt;/a&gt;&lt;strong&gt;1：文本摘要项目理论&lt;/strong&gt;&lt;/h2&gt;&lt;h4 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://xiaoyvlongoing.github.io/2021/06/10/1%EF%BC%9A%E6%96%87%E6%9C%AC%E6%91%98%E8%A6%81%E9%A1%B9%E7%9B%AE%E7%90%86%E8%AE%BA/"/>
    <id>https://xiaoyvlongoing.github.io/2021/06/10/1%EF%BC%9A%E6%96%87%E6%9C%AC%E6%91%98%E8%A6%81%E9%A1%B9%E7%9B%AE%E7%90%86%E8%AE%BA/</id>
    <published>2021-06-09T16:48:30.753Z</published>
    <updated>2021-06-09T16:51:57.772Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1：文本摘要项目理论"><a href="#1：文本摘要项目理论" class="headerlink" title="1：文本摘要项目理论"></a><strong>1：文本摘要项目理论</strong></h2><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p><strong>文本摘要思想</strong>：就是一个长文本把重要的摘要出来</p><h5 id="1：NLP角度来看文本摘要任务，主流的概括两大方法："><a href="#1：NLP角度来看文本摘要任务，主流的概括两大方法：" class="headerlink" title="1：NLP角度来看文本摘要任务，主流的概括两大方法："></a>1：NLP角度来看文本摘要任务，主流的概括两大方法：</h5><ul><li>抽取式摘要：Extraction-based（从文本中抽取）：直接从原文中选择若干条重要的句子, 并对它们进行排序和重组, 以形成摘要的方法.<ul><li><strong>无监督抽取</strong>：不需要平行语料, 节省了人工标记的成本. 大体上有如下几种:<ul><li>Lead</li><li>Centroid</li><li>ClusterCMRW</li><li>TextRank：最经典</li></ul></li><li><strong>有监督抽取：</strong>将文本摘要抽象成二分类问题, 通过神经网络来学习句子及其标签之间的对应关系. 需要平行语料, 需要人工标记的成本. 常见方法有如下几种<ul><li>R2N2</li><li>NeuralSum</li><li>SummaRuNNer</li><li><strong>BertSum</strong>：原本用来计算网页之间的关联性，后来被应用在句子上，句子之间反复传播，选出最关键的语句进行排序。因为文章总有中心句，而textrank就试图找出这个中心句。</li></ul></li><li>取式<strong>缺点</strong>：主要考虑单词词频，没有过多的语义信息，所以无法建立段落中的完整语义信息</li></ul></li><li><strong>生成式摘要: Abstraction-based：</strong>需要通过<strong>转述、同义替换、句子缩写</strong>等生成。<ul><li>生成式神经网络模型的基本结构主要由<strong>编码器（encoder）和解码器（decoder）</strong>组成，编码和解码都由神经网络实现。<ul><li><strong>编码器</strong>负责将输入的原文本编码成一个<strong>向量C（context），</strong></li><li><strong>而解码器</strong>负责从这个<strong>向量C</strong>提取<strong>重要信息、加工剪辑，生成文本摘要。</strong></li><li><strong>Sequence-to-Sequence</strong>（以下简称Seq2Seq），被广泛应用于存在输入序列和输出序列的场景，比如机器翻译（一种语言序列到另一种语言序列）、image captioning（图片像素序列到语言序列）、对话机器人（如问题到回答）等</li></ul></li></ul></li></ul><h4 id="2：数据的处理："><a href="#2：数据的处理：" class="headerlink" title="2：数据的处理："></a>2：数据的处理：</h4><p>一般来说, 在任何项目中, 面对原始数据都要进行接下来的几点工作:</p><ul><li>删除空值.</li><li>删除”脏”数据.<ul><li>在这个数据集中的脏数据为：<ul><li>有很多的技师说和，车主说</li><li>文本中有很多的图片字样和语音字样</li><li>有很多进口，车型，还有一些符号</li></ul></li></ul></li><li>删除特定字符的集合.</li><li>分词.</li><li>完成字符到id的映射.</li><li>完成padding, cutting的工作.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">train_path = <span class="string">&#x27;train.csv&#x27;</span></span><br><span class="line">test_path = <span class="string">&#x27;test.csv&#x27;</span></span><br><span class="line"></span><br><span class="line">df = pd.read_csv(train_path, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">df.info()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;**********************&#x27;</span>)</span><br><span class="line"></span><br><span class="line">df = pd.read_csv(test_path, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">df.info()</span><br></pre></td></tr></table></figure><h4 id="打印："><a href="#打印：" class="headerlink" title="打印："></a>打印：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">pandas</span>.<span class="title">core</span>.<span class="title">frame</span>.<span class="title">DataFrame</span>&#x27;&gt;</span></span><br><span class="line"><span class="class"><span class="title">RangeIndex</span>:</span> <span class="number">82943</span> entries, <span class="number">0</span> to <span class="number">82942</span></span><br><span class="line">Data columns (total <span class="number">6</span> columns):</span><br><span class="line"> <span class="comment">#   Column    Non-Null Count  Dtype </span></span><br><span class="line"></span><br><span class="line"> <span class="number">0</span>   QID       <span class="number">82943</span> non-null  <span class="built_in">object</span></span><br><span class="line"> <span class="number">1</span>   Brand     <span class="number">81642</span> non-null  <span class="built_in">object</span></span><br><span class="line"> <span class="number">2</span>   Model     <span class="number">81642</span> non-null  <span class="built_in">object</span></span><br><span class="line"> <span class="number">3</span>   Question  <span class="number">82943</span> non-null  <span class="built_in">object</span></span><br><span class="line"> <span class="number">4</span>   Dialogue  <span class="number">82941</span> non-null  <span class="built_in">object</span></span><br><span class="line"> <span class="number">5</span>   Report    <span class="number">82873</span> non-null  <span class="built_in">object</span></span><br><span class="line">dtypes: <span class="built_in">object</span>(<span class="number">6</span>)</span><br><span class="line">memory usage: <span class="number">3.8</span>+ MB</span><br><span class="line"></span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">pandas</span>.<span class="title">core</span>.<span class="title">frame</span>.<span class="title">DataFrame</span>&#x27;&gt;</span></span><br><span class="line"><span class="class"><span class="title">RangeIndex</span>:</span> <span class="number">20000</span> entries, <span class="number">0</span> to <span class="number">19999</span></span><br><span class="line">Data columns (total <span class="number">5</span> columns):</span><br><span class="line"> <span class="comment">#   Column    Non-Null Count  Dtype </span></span><br><span class="line"></span><br><span class="line"> <span class="number">0</span>   QID       <span class="number">20000</span> non-null  <span class="built_in">object</span></span><br><span class="line"> <span class="number">1</span>   Brand     <span class="number">19987</span> non-null  <span class="built_in">object</span></span><br><span class="line"> <span class="number">2</span>   Model     <span class="number">19987</span> non-null  <span class="built_in">object</span></span><br><span class="line"> <span class="number">3</span>   Question  <span class="number">20000</span> non-null  <span class="built_in">object</span></span><br><span class="line"> <span class="number">4</span>   Dialogue  <span class="number">20000</span> non-null  <span class="built_in">object</span></span><br><span class="line">dtypes: <span class="built_in">object</span>(<span class="number">5</span>)</span><br><span class="line">memory usage: <span class="number">781.4</span>+ KB</span><br></pre></td></tr></table></figure><h4 id="3：TextRank：算法理论基础"><a href="#3：TextRank：算法理论基础" class="headerlink" title="3：TextRank：算法理论基础"></a>3：TextRank：算法理论基础</h4><p>对比于衡量网页重要性的PageRank算法, TextRank算法用于衡量哪些单词是关键词, 类比之下的算法思想也就很好理解了:</p><ul><li>如果一个单词出现在很多单词的后面, 就是它和很多单词有关联, 那么说明这个单词比较重要.</li><li>如果一个TextRank值很高的单词后面跟着另一个单词, 那么后面这个单词的TextRank值也会相应的被提高.</li></ul><h4 id="3-1：TextRank算法代码实践"><a href="#3-1：TextRank算法代码实践" class="headerlink" title="3.1：TextRank算法代码实践"></a>3.1：TextRank算法代码实践</h4><ul><li>在本小节中, 我们仅以示例代码跑通几段小程序, 让同学们掌握如何具体在代码层面用TextRank.<ul><li>关键词抽取(keyword extraction)：是指从文本中确定一些能够描述文档含义的关键术语的过程<ul><li>对关键词抽取而言, 用于构建顶点集的文本单元可以使句子中的一个或多个字. 根据这些字之间的关系构建边.</li><li>根据任务的需要, 可以使用语法过滤器(syntactic filters)对顶点集进行优化. 语法过滤器的主要作用是将某一类或者某几类词性的字过滤出来作为顶点集.</li></ul></li><li>关键短语抽取(keyphrase extraction)</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1：文本摘要项目理论&quot;&gt;&lt;a href=&quot;#1：文本摘要项目理论&quot; class=&quot;headerlink&quot; title=&quot;1：文本摘要项目理论&quot;&gt;&lt;/a&gt;&lt;strong&gt;1：文本摘要项目理论&lt;/strong&gt;&lt;/h2&gt;&lt;h4 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://xiaoyvlongoing.github.io/2021/05/23/%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%9A%E6%97%A0%E5%BA%8F%E6%89%A7%E8%A1%8C/"/>
    <id>https://xiaoyvlongoing.github.io/2021/05/23/%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%9A%E6%97%A0%E5%BA%8F%E6%89%A7%E8%A1%8C/</id>
    <published>2021-05-23T15:23:35.157Z</published>
    <updated>2021-05-22T16:59:18.113Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th>函数名</th><th>使用的方法</th></tr></thead><tbody><tr><td>导入的函数包import multiprocessing</td><td>创建的进程导入的包名</td></tr><tr><td>multiprocessing.Process([group [, target [, name [, args：传入指定形参 [, kwargs：以字典的类型进行传参]]]]])</td><td>导入进程函数说明</td></tr><tr><td>target=方法名</td><td>执行的目标任务名（函数名，线程名）</td></tr><tr><td>name=进程的名字</td><td>进程名字</td></tr><tr><td>对象名=multiprocessing.Process(target=方法名)</td><td>启动进程的方法</td></tr><tr><td>子进程对象.start()</td><td>对象.start（）：启动子进程实例（创建子进程）</td></tr><tr><td>os.getpid</td><td>print(os.getpid)查看子进程编号</td></tr><tr><td>os.getppid</td><td>print(os.getppid)查看父进程编号</td></tr><tr><td>multiprocessing.current_process().name进程名字</td><td>查看当前进程编号</td></tr><tr><td>子进程对象.join()</td><td>加入jojn后主线程会等待子线程执行后再结束主线程，让线程可以形成串行，形成有顺序的，线性和进程的也可进行串行，结束前一个，进行下一个执行</td></tr><tr><td>子进程对象.terminate()</td><td>不管任务是否完成，立即终止子进程</td></tr><tr><td>子进程对象.daemom = True</td><td>不管任务是否完成，立即终止子进程</td></tr><tr><td>进程在ubuntu中 ps -aux|grep 要查找的线程的名字</td><td>过滤需要的进程来查看ID</td></tr><tr><td>os.kill(os.getpid(),9)  进程的id</td><td>强制杀死进程</td></tr><tr><td></td><td></td></tr></tbody></table><h2 id="多线程：无序执行"><a href="#多线程：无序执行" class="headerlink" title="多线程：无序执行"></a>多线程：无序执行</h2><table><thead><tr><th>函数名</th><th>使用方法</th></tr></thead><tbody><tr><td>import threading</td><td>创建线程的包</td></tr><tr><td>方法名= threading.Thread(target=方法名)</td><td>启动进程的方法</td></tr><tr><td>对象名 = threading.Thread(target=方法名,daemon= True)</td><td>主线程结束，会让子线程结束(方法1）</td></tr><tr><td>对象名 .setDaemon(True)：在启动线程之前</td><td>主线程结束，会让子线程结束(方法2）</td></tr><tr><td>current = threading.current_thread().name</td><td>获取线程的名称</td></tr><tr><td>多线程不能强制杀死，要把线程进行循环停止加上一个          变量 =</td><td></td></tr><tr><td>lock = threading.Lock()</td><td>创建互斥锁</td></tr><tr><td>lock.acquire()</td><td>创建锁</td></tr><tr><td>lock.release</td><td>解锁</td></tr></tbody></table><p>[TOC]</p><p>1：进程是操作系统资源分配的最小单位</p><p>2：进程之间执行也是无序的，它是由操作系统调度决定的，操作系统调度哪个进程，哪个进程就先执行，没有调度的进程不能执行</p><p>3：进程不共享全局变量</p><p>二：线程和进程有什么区别：</p><p>1：进程是操作系统资源分配的最小单位，线程是cpu调度的最小单位</p><p>2：线程依附于进程，没有进程就没有线程，一个进程默认创造一个主线程，一个进程可以创造多个线程</p><p>3：进程不共享全局变量，而同一个进程的线程可以共享进程的全局变量</p><p>4：进程开销比较大，可以利用多核（并行），线程开销比较小不能利用多核（并发）</p><p>三：什么是主进程：</p><p>主进程是：程序执行的入口，一个进程里默认带一个线程，主进程可以创建多个子线程，</p><p>四：写出创造进程的步骤：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>：导入进程包：</span><br><span class="line"></span><br><span class="line">​<span class="keyword">import</span>  multiprocessing</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>：创建进程函数（方法）</span><br><span class="line"></span><br><span class="line">​<span class="function"><span class="keyword">def</span> <span class="title">num</span>（）：</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">​<span class="title">pass</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">3：创建进程，调用进程函数（方法）</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">​变量 = <span class="title">multiprocessing</span>.<span class="title">Process</span>(<span class="params">target = num</span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">4:</span>启动进程</span><br><span class="line"></span><br><span class="line">变量.start（）</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>五：怎么获得进程的pid</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>：improre  os </span><br><span class="line"></span><br><span class="line"><span class="number">2</span>：os.getppid :   <span class="built_in">print</span>(os.getppid)查看父进程<span class="built_in">id</span>编号</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>：os.getpid  ：   <span class="built_in">print</span>（os.getpid）查看当前进程<span class="built_in">id</span>编号</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>：multiprocessing.current_process().name进程（线程）名字   ：查看当前进程（线程）的<span class="built_in">id</span>编号    </span><br></pre></td></tr></table></figure><p>六：怎么给进程函数传递参数：</p><p>1：通过元组进程传递参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">multiprocessing.Process(target = coding , args = （参数，）)</span><br><span class="line">传入的是一个元组需要加上，传入的参数要保持一致</span><br></pre></td></tr></table></figure><p>2：通过字典进程传参：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">multiprocessing.Process(target = coding , kwargs = &#123;传递的进程变量名：传入的参数&#125;)</span><br><span class="line">因为用的是字典的要与进程参数对住</span><br></pre></td></tr></table></figure><h2 id="七：在主进程中，怎么堵塞等待子进程完成后，才能继续运行"><a href="#七：在主进程中，怎么堵塞等待子进程完成后，才能继续运行" class="headerlink" title="七：在主进程中，怎么堵塞等待子进程完成后，才能继续运行"></a>七：在主进程中，怎么堵塞等待子进程完成后，才能继续运行</h2><p>1：把join加入到子进程中，子进程变量.join，形成串联运行完子进程在运行主线线程</p><p>八：Process创建的实例对象的常用的方法有什么？</p><p>1：start（）：启动子进程实例（创建子进程）</p><p>2：join（）：等待子进程执行结束，形成串联</p><p>3：terminate（）：不管任务是否完成，立即终止子进程</p><p>八《一》：    Process常用的属性：</p><p>1：name：当前进程的别名，默认为Process - n ，n为从1开始递增的整数</p><p>2：pid：当前进程的id</p><p>九：编写一个程序，实现创建一个子进程，子进程每一秒打印一次：这是子进程，循环的第n次，打印 的次数是由主进程传递给子进程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">1：#利用args和kwargs传参</span><br><span class="line">import multiprocessing</span><br><span class="line">import time</span><br><span class="line">def ness(num):</span><br><span class="line">    for i in range(num):</span><br><span class="line">        time.sleep(1)</span><br><span class="line">        print(&quot;这个是一个线程&quot;)</span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    # mues = multiprocessing.Process(target= ness,args=(6,))</span><br><span class="line">    mues = multiprocessing.Process(target=ness, kwargs=&#123;&quot;num&quot;:6&#125;)</span><br><span class="line">    mues.start()</span><br><span class="line"></span><br><span class="line">2：#利用类方法实现线程</span><br><span class="line">import multiprocessing</span><br><span class="line">import time</span><br><span class="line">class nees():</span><br><span class="line">    def __init__(self,name):</span><br><span class="line">        super(nees, self).__init__()</span><br><span class="line">        self.name = name</span><br><span class="line">    def num(self):</span><br><span class="line">        for i in range(self.name):</span><br><span class="line">            time.sleep(1)</span><br><span class="line">            print(&quot;这个是一个子进程&quot;)</span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    num_process = multiprocessing.Process(target=nees)</span><br><span class="line">    A=nees(3)</span><br><span class="line">    A.num()</span><br></pre></td></tr></table></figure><p>：线程资源竞争问题：</p><p>1：100万次加法，线程1和线程2谁先执行完</p><p>2：线程1计算的结果一定比线程2小吗？</p><p>3：某个线程计算的结果有没有可能小于100万？为什么：</p><p>​            1：不一定谁先执行完，因为线程是由cpu进行调度的，没有执行顺序那个先执行完都是不一定的</p><p>​            2：不一定，因为没办法知道那个线程能先执行完，所有没有办法知道执行的时间，没有办法知道执行的大小</p><p>​            3：有的，因为多线程共享全局变量，再赋予全局变量的时候，线程一和线程二计算的先后没有办法确定下来，当线程一计算的多时，线程二计算的少时，线程一又把线程二中的值共享过来这时就不安之前的顺序的，会小于100万</p>]]></content>
    
    
      
      
    <summary type="html">&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;函数名&lt;/th&gt;
&lt;th&gt;使用的方法&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;导入的函数包import multiprocessing&lt;/td&gt;
&lt;td&gt;创建的进程导入的包名&lt;/td&gt;
&lt;/tr&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://xiaoyvlongoing.github.io/2021/05/23/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8BTC/"/>
    <id>https://xiaoyvlongoing.github.io/2021/05/23/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8BTC/</id>
    <published>2021-05-23T15:23:35.157Z</published>
    <updated>2021-06-08T07:02:13.631Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="网络编程TC"><a href="#网络编程TC" class="headerlink" title="网络编程TC"></a>网络编程TC</h2><h2 id="网络编程TC-1"><a href="#网络编程TC-1" class="headerlink" title="网络编程TC"></a>网络编程TC</h2><p>[TOC]</p><h2 id="P客户端"><a href="#P客户端" class="headerlink" title="P客户端"></a>P客户端</h2><table><thead><tr><th align="center">变量名称</th><th>变量使用方法</th></tr></thead><tbody><tr><td align="center">ifconfig</td><td>查看网络的ip</td></tr><tr><td align="center">ping</td><td>查看网络是否连通</td></tr><tr><td align="center">socket</td><td>网络编程包</td></tr><tr><td align="center">socket.AF_INET</td><td>ip地址</td></tr><tr><td align="center">socket.SOCK_STREAM</td><td>端口</td></tr><tr><td align="center">tcp_clien_socket.connect</td><td>客户端：传入ip和端口，用于建立与指定指定socket的连接</td></tr><tr><td align="center">tcp_clien_socket.send（字符串.encode(encoding=”utf-8”)）</td><td>send（）：把数据组转换成二进制，encode：写入编辑的字符串和要转成数据组的函数：encode（encoding = “”）</td></tr><tr><td align="center">字符串.encode(encoding=”utf-8”)）</td><td>encode：把字符串转换成数据组</td></tr><tr><td align="center">tcp_clien_socket.recv(数值)</td><td>套接字最大传入数据数值，接收来自socket缓存区对字节数据，当缓存区没有数值时会一直进行阻塞</td></tr><tr><td align="center">.decode()</td><td>对服务端发来的数据进行解码</td></tr><tr><td align="center">conn_socket.close()</td><td>关闭套接字</td></tr></tbody></table><h2 id="网络编程TCP服务端"><a href="#网络编程TCP服务端" class="headerlink" title="网络编程TCP服务端"></a>网络编程TCP服务端</h2><table><thead><tr><th>变量名称</th><th>变量使用方法</th></tr></thead><tbody><tr><td>socket</td><td>网络编程包</td></tr><tr><td>bind</td><td>服务端：创建ip和端口</td></tr><tr><td>tcp_evens_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True)</td><td>端口的复用</td></tr><tr><td>tcp_sever_socket.listen（数值）</td><td>设置端口监听功能监听多少个数值上限</td></tr><tr><td>tcp_server_socket.accept()</td><td><code>accept()</code>接受一个客户端的连接请求，接收的数据用于recv，并返回一个新的套接字，用于了send分开数据和ip不同于以上<code>socket()</code>返回的用于监听和接受客户端的连接请求的套接字；，</td></tr></tbody></table><h2 id="扩展函数："><a href="#扩展函数：" class="headerlink" title="扩展函数："></a>扩展函数：</h2><table><thead><tr><th>函数</th><th>函数表达意思</th></tr></thead><tbody><tr><td>client_socket.recv(1024).<strong>decode()</strong></td><td>decode()：将查询的值翻译成其他的值，以其他形式表现出来</td></tr><tr><td><strong>os.listdir</strong></td><td>方法用于返回指定的文件夹包含的文件或文件夹的名字的列表。</td></tr><tr><td><strong>os.path.getsize()</strong></td><td><strong>获得文件的大小（字节）</strong></td></tr><tr><td>f.read（）</td><td>从文件指针所在的位置开始读</td></tr><tr><td>isdigit</td><td></td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="静态服务器："><a href="#静态服务器：" class="headerlink" title="静态服务器："></a>静态服务器：</h2><table><thead><tr><th>函数</th><th>函数定义</th></tr></thead><tbody><tr><td>.open（“地址”，“要读或写”）</td><td>用于打开一个文件，创建一个 file 对象，相关的方法才可以调用它进行读写。</td></tr><tr><td>.read()</td><td>读取文件信息内容</td></tr><tr><td>英文：response</td><td>翻译：相应</td></tr><tr><td>英文：Server</td><td>翻译：服务器</td></tr><tr><td>localhost:8080</td><td>浏览器查看</td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table><h2 id="使用多线程多客户端连接服务器，多发送信息"><a href="#使用多线程多客户端连接服务器，多发送信息" class="headerlink" title="使用多线程多客户端连接服务器，多发送信息"></a>使用多线程多客户端连接服务器，多发送信息</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">duoe_sock</span>(<span class="params">code_sock</span>):</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        recv_data = code_sock.recv(<span class="number">1024</span>)</span><br><span class="line">        data = recv_data.decode()</span><br><span class="line">        <span class="built_in">print</span>(data)</span><br><span class="line">        code_sock.send(<span class="string">&quot;niaho1&quot;</span>.encode())</span><br><span class="line">        <span class="keyword">if</span> data == <span class="string">&quot;quit&quot;</span> <span class="keyword">or</span> <span class="keyword">not</span> data:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;连接关闭&quot;</span>)</span><br><span class="line">    code_sock.close()</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    tcp_evelt_socket = socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">    tcp_evelt_socket.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,<span class="literal">True</span>)</span><br><span class="line">    tcp_evelt_socket.bind((<span class="string">&quot;&quot;</span>,<span class="number">8080</span>))</span><br><span class="line">    tcp_evelt_socket.listen(<span class="number">128</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        code_sock,ip_lies = tcp_evelt_socket.accept()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;ip:&quot;</span>,ip_lies)</span><br><span class="line">        smeus_pskd = threading.Thread(target=duoe_sock,args=(code_sock,))</span><br><span class="line">        smeus_pskd.start()</span><br><span class="line">    code_sock.close()</span><br></pre></td></tr></table></figure><h2 id="静态服务器返回固态页面："><a href="#静态服务器返回固态页面：" class="headerlink" title="静态服务器返回固态页面："></a>静态服务器返回固态页面：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    tcp_serer_sock = socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">    tcp_serer_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="literal">True</span>)</span><br><span class="line">    tcp_serer_sock.bind((<span class="string">&quot;&quot;</span>,<span class="number">8080</span>))</span><br><span class="line">    tcp_serer_sock.listen(<span class="number">800</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        clien_sock,client_abbr = tcp_serer_sock.accept()</span><br><span class="line">        clien_request_data = clien_sock.recv(<span class="number">10230</span>).decode()</span><br><span class="line">        <span class="built_in">print</span>(clien_request_data)</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;./nksld.html&quot;</span>,<span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:<span class="comment">#打开文件夹有会报错，异常处理</span></span><br><span class="line">            <span class="comment"># f = open(&quot;当前文件夹&quot;,&quot;rb&quot;)</span></span><br><span class="line">            file_data = f.read()</span><br><span class="line">        <span class="comment"># 应答行</span></span><br><span class="line">        response_line = <span class="string">&quot;HTTP/1.1 200 OK\r\n&quot;</span></span><br><span class="line">        <span class="comment"># 头</span></span><br><span class="line">        response_header = <span class="string">&quot;Server:pwd\r\n&quot;</span></span><br><span class="line">        <span class="comment"># 体</span></span><br><span class="line">        response_body = file_data<span class="comment">#界面的数据</span></span><br><span class="line">        <span class="comment">#应答数据</span></span><br><span class="line">        response_data= (response_line + response_header + <span class="string">&quot;\r\n&quot;</span>).encode() + response_body</span><br><span class="line">        clien_sock.send(response_data)</span><br><span class="line"></span><br><span class="line">        clien_sock.close()</span><br></pre></td></tr></table></figure><h2 id="静态服务器返回指定页面"><a href="#静态服务器返回指定页面" class="headerlink" title="静态服务器返回指定页面"></a>静态服务器返回指定页面</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    tcp_server_sock = socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">    tcp_server_sock.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,<span class="literal">True</span>)</span><br><span class="line">    tcp_server_sock.bind((<span class="string">&quot;&quot;</span>,<span class="number">8080</span>))</span><br><span class="line">    tcp_server_sock.listen(<span class="number">123</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        tcp_sock,ip_sock = tcp_server_sock.accept()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;ip&quot;</span>,ip_sock)</span><br><span class="line">        recv_data = tcp_sock.recv(<span class="number">1024</span>).decode()</span><br><span class="line">        spli_dat = recv_data.split()</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(spli_dat) &lt;=<span class="number">1</span>:</span><br><span class="line">            tcp_sock.close()</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;浏览器关闭&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            data = spli_dat[<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> data == <span class="string">&quot;/&quot;</span>:</span><br><span class="line">                data = <span class="string">&quot;/001.jpg&quot;</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;.&quot;</span>+ data,<span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                    f_data = f.read()</span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                tecponse_hine = <span class="string">&quot;HTTP/1.1 404 NG\r\n&quot;</span></span><br><span class="line">                tecponse_toue = <span class="string">&quot;Server : long\r\n&quot;</span></span><br><span class="line">                tecponse_toes = <span class="string">&quot;404 NG\r\n&quot;</span></span><br><span class="line">                tecponse_zhen = (tecponse_hine+tecponse_toue+<span class="string">&quot;\r\n&quot;</span>+tecponse_toes).encode()</span><br><span class="line">                tcp_sock.send(tecponse_zhen)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                tecponse_hine = <span class="string">&quot;HTTP/1.1 200 OK\r\n&quot;</span></span><br><span class="line">                tecponse_toue = <span class="string">&quot;Server : long\r\n&quot;</span></span><br><span class="line">                tecponse_toes = f_data</span><br><span class="line">                tecponse_zhen = (tecponse_hine  + tecponse_toue+ <span class="string">&quot;\r\n&quot;</span>).encode()+ tecponse_toes</span><br><span class="line">                tcp_sock.send(tecponse_zhen)</span><br><span class="line">            <span class="keyword">finally</span>:</span><br><span class="line">                tcp_sock.close()</span><br></pre></td></tr></table></figure><h2 id="静态服务器多线程任务"><a href="#静态服务器多线程任务" class="headerlink" title="静态服务器多线程任务"></a>静态服务器多线程任务</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nuws_sock</span>(<span class="params">tcp_sock</span>):</span></span><br><span class="line">    recv_data = tcp_sock.recv(<span class="number">1024</span>).decode()</span><br><span class="line">    spli_dat = recv_data.split()</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(spli_dat) &lt;=<span class="number">1</span>:</span><br><span class="line">        tcp_sock.close()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;浏览器关闭&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        data = spli_dat[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> data == <span class="string">&quot;/&quot;</span>:</span><br><span class="line">            data = <span class="string">&quot;/001.jpg&quot;</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;.&quot;</span>+ data,<span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                f_data = f.read()</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            tecponse_hine = <span class="string">&quot;HTTP/1.1 404 NG\r\n&quot;</span></span><br><span class="line">            tecponse_toue = <span class="string">&quot;Server : long\r\n&quot;</span></span><br><span class="line">            tecponse_toes = <span class="string">&quot;404 NG\r\n&quot;</span></span><br><span class="line">            tecponse_zhen = (tecponse_hine+tecponse_toue+<span class="string">&quot;\r\n&quot;</span>+tecponse_toes).encode()</span><br><span class="line">            tcp_sock.send(tecponse_zhen)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            tecponse_hine = <span class="string">&quot;HTTP/1.1 200 OK\r\n&quot;</span></span><br><span class="line">            tecponse_toue = <span class="string">&quot;Server : long\r\n&quot;</span></span><br><span class="line">            tecponse_toes = f_data</span><br><span class="line">            tecponse_zhen = (tecponse_hine  + tecponse_toue+ <span class="string">&quot;\r\n&quot;</span>).encode()+ tecponse_toes</span><br><span class="line">            tcp_sock.send(tecponse_zhen)</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            tcp_sock.close()</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    tcp_server_sock = socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">    tcp_server_sock.setsockopt(socket.SOL_SOCKET,socket.SO_REUSEADDR,<span class="literal">True</span>)</span><br><span class="line">    tcp_server_sock.bind((<span class="string">&quot;&quot;</span>,<span class="number">8080</span>))</span><br><span class="line">    tcp_server_sock.listen(<span class="number">123</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        tcp_sock,ip_sock = tcp_server_sock.accept()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;ip&quot;</span>,ip_sock)</span><br><span class="line">        nues_sock =  threading.Thread(target=nuws_sock,args=(tcp_sock,))</span><br><span class="line">        nues_sock.start()</span><br></pre></td></tr></table></figure><h2 id="静态服务器对象调用"><a href="#静态服务器对象调用" class="headerlink" title="静态服务器对象调用"></a>静态服务器对象调用</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pues_sock</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.tcp_server_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">        self.tcp_server_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="literal">True</span>)</span><br><span class="line">        self.tcp_server_sock.bind((<span class="string">&quot;&quot;</span>, <span class="number">8080</span>))</span><br><span class="line">        self.tcp_server_sock.listen(<span class="number">123</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nuws_sock</span>(<span class="params">self,tcp_sock</span>):</span></span><br><span class="line">        recv_data = tcp_sock.recv(<span class="number">1024</span>).decode()</span><br><span class="line">        spli_dat = recv_data.split()</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(spli_dat) &lt;=<span class="number">1</span>:</span><br><span class="line">            tcp_sock.close()</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;浏览器关闭&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            data = spli_dat[<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">if</span> data == <span class="string">&quot;/&quot;</span>:</span><br><span class="line">                data = <span class="string">&quot;/001.jpg&quot;</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;.&quot;</span>+ data,<span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                    f_data = f.read()</span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                tecponse_hine = <span class="string">&quot;HTTP/1.1 404 NG\r\n&quot;</span></span><br><span class="line">                tecponse_toue = <span class="string">&quot;Server : long\r\n&quot;</span></span><br><span class="line">                tecponse_toes = <span class="string">&quot;404 NG\r\n&quot;</span></span><br><span class="line">                tecponse_zhen = (tecponse_hine+tecponse_toue+<span class="string">&quot;\r\n&quot;</span>+tecponse_toes).encode()</span><br><span class="line">                tcp_sock.send(tecponse_zhen)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                tecponse_hine = <span class="string">&quot;HTTP/1.1 200 OK\r\n&quot;</span></span><br><span class="line">                tecponse_toue = <span class="string">&quot;Server : long\r\n&quot;</span></span><br><span class="line">                tecponse_toes = f_data</span><br><span class="line">                tecponse_zhen = (tecponse_hine  + tecponse_toue+ <span class="string">&quot;\r\n&quot;</span>).encode()+ tecponse_toes</span><br><span class="line">                tcp_sock.send(tecponse_zhen)</span><br><span class="line">            <span class="keyword">finally</span>:</span><br><span class="line">                tcp_sock.close()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">nuse_sock</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            tcp_sock, ip_sock = self.tcp_server_sock.accept()</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;ip&quot;</span>, ip_sock)</span><br><span class="line">            nues_sock = threading.Thread(target=self.nuws_sock, args=(tcp_sock,))</span><br><span class="line">            nues_sock.start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">    nues = Pues_sock()</span><br><span class="line">    nues.nuse_sock()</span><br></pre></td></tr></table></figure><h2 id="静态服务器变换端口号"><a href="#静态服务器变换端口号" class="headerlink" title="静态服务器变换端口号"></a>静态服务器变换端口号</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="comment"># 获取执行python程序的终端命令行参数</span></span><br><span class="line">    <span class="built_in">print</span>(sys.argv)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) != <span class="number">2</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;格式错误 python3 xxx.py 9090&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># 判断参数的类型，设置端口号必须是整型</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> sys.argv[<span class="number">1</span>].isdigit():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;格式错误 python3 xxx.py 9090&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    port = <span class="built_in">int</span>(sys.argv[<span class="number">1</span>])</span><br><span class="line">    <span class="comment"># 创建服务器对象</span></span><br><span class="line">    <span class="comment"># 给Web服务器类的初始化方法添加一个端口号参数，用于绑定端口号</span></span><br><span class="line">    my_web_server = HttpWebServer(port)</span><br><span class="line">    <span class="comment"># 启动服务器</span></span><br><span class="line">    my_web_server.start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h2 id="TCP协议是什么？提示：TCP定义及特点"><a href="#TCP协议是什么？提示：TCP定义及特点" class="headerlink" title="TCP协议是什么？提示：TCP定义及特点"></a>TCP协议是什么？提示：TCP定义及特点</h2><h4 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h4><p>传输控制协议，是一种面向连接，可靠的，基于字节流的传输层通讯协议</p><h5 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h5><p>面向连接：通信双方必须先建立好连接才能进行数据的传输，数据传输完成后，双方必须断开连接，以释放系统资源</p><p>可靠的通信方式</p><p>基于字节流</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="2-TCP特点是什么？"><a href="#2-TCP特点是什么？" class="headerlink" title="2. TCP特点是什么？"></a>2. TCP特点是什么？</h2><p>提示：TCP特点及解释说明</p><p>基于字节流的</p><p>面向连接</p><p>可靠通信</p><p>在网络状况不佳的时候尽量降低系统由于重传带来的宽开销</p><p>通信连接维护是面向通信的两个端点，而不考虑中间网段和节点</p><h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><h2 id="3-在TCP客户端使用connect的作用是什么？"><a href="#3-在TCP客户端使用connect的作用是什么？" class="headerlink" title="3. 在TCP客户端使用connect的作用是什么？"></a>3. 在TCP客户端使用connect的作用是什么？</h2><p>提示：connect的作用及connect()函数的参数形式</p><p>connenct：用于建立与指定指定socket的连接，对于流类套接口（SOCK—STREAMl类型），利用名字来与一个远程主机建立连接，一但套用接口调用成功，他就能收发数据，对于数据报类套接口（SOCK—STREAMl类型），则设置成一个缺省的目的并用它来进行后序的send与recv调用</p><h3 id="4-在TCP服务器中listen的作用是什么？"><a href="#4-在TCP服务器中listen的作用是什么？" class="headerlink" title="4. 在TCP服务器中listen的作用是什么？"></a>4. 在TCP服务器中listen的作用是什么？</h3><p>提示：listen()函数的作用及参数含义、</p><p>在网络中服务端是被动的，客户是主动的，被动要用listen来监听，listen（）作用是将socket（）得到一个sockfd被动监听的套接字，来通知内核来完成连接</p><h2 id="-2"><a href="#-2" class="headerlink" title=""></a></h2><h2 id="5-简述tcp客户端创建的流程。"><a href="#5-简述tcp客户端创建的流程。" class="headerlink" title="5. 简述tcp客户端创建的流程。"></a>5. 简述tcp客户端创建的流程。</h2><p>提示：参考课件代码说出客户端创建步骤</p><p>创建一个套接字协议用：connenct赖建立连接</p><p>导入IP地址可端口</p><p>创建发送的数据用send（数据encode），先把字符串转换成数据组，在把数据组装换成二进制</p><p>设置最大字节数据：recv（）</p><p>接收客户端发来的数据用decode来解码</p><p>关闭套接字用close</p><h2 id="-3"><a href="#-3" class="headerlink" title=""></a></h2><h2 id="6-recv函数的参数表示什么含义？"><a href="#6-recv函数的参数表示什么含义？" class="headerlink" title="6. recv函数的参数表示什么含义？"></a>6. recv函数的参数表示什么含义？</h2><p>提示：recv()函数的作用及参数含义</p><p>接收来自socket缓存区对字节数据，当缓存区没有数值时会一直进行阻塞，直到有数据时进行读取，远程关闭并读取所有数据之后会返回空字符串</p><h2 id="7-简述TCP服务器创建的流程、"><a href="#7-简述TCP服务器创建的流程、" class="headerlink" title="7. 简述TCP服务器创建的流程、"></a>7. 简述TCP服务器创建的流程、</h2><p>提示：参考课件代码，说出服务器创建流程</p><p>1：创建套接字，进行网络协议</p><p>2：进行端口复用</p><p>3：进行bind进行套接字协议</p><p>4：进行与服务端监听连接的最大数值，listen</p><p>5：accept（）接收数据再返回一个新的socket字，接收的数据用于recv，返回客户端的数据用于了send分开数据和ip，</p><p>6：进行设置recv进行数据的阻塞，</p><p>7：给客户端发送一个数据用send（encode）来转成二进制</p><p>8：接收客户端发来的数据，用decode来进行解码</p><h2 id="8-accept的返回值分别代表的什么？"><a href="#8-accept的返回值分别代表的什么？" class="headerlink" title="8. accept的返回值分别代表的什么？"></a>8. accept的返回值分别代表的什么？</h2><p>提示：accept()函数的作用，及返回值的形式和返回值的含义</p><p>accept（）接收数据再返回一个新的socket字，接收的数据用于recv，返回客户端的数据用于了send分开数据和ip，</p><h2 id="9-完成TCP客户端的编写。"><a href="#9-完成TCP客户端的编写。" class="headerlink" title="9. 完成TCP客户端的编写。"></a>9. 完成TCP客户端的编写。</h2><p>服务器的ip和端口号需手动输入</p><p>要发送的信息需要手动输入</p><p>接收服务器返回的数据，并打印。</p><p>请在下方的注释下补充代码：</p><p>​       # 导入socket模块</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import socket</span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    tcp_codne_socket = socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">    tcp_codne_socket.connect((&quot;&quot;,8080))</span><br><span class="line">    tcp_codne_socket.send(&quot;&quot;.encode())</span><br><span class="line">    cone_recv = tcp_codne_socket.recv(1024)</span><br><span class="line">    print(cone_recv.decode())</span><br><span class="line">    tcp_codne_socket.close()</span><br></pre></td></tr></table></figure><h2 id="-4"><a href="#-4" class="headerlink" title=""></a></h2><h2 id="10-完成TCP服务的的编写"><a href="#10-完成TCP服务的的编写" class="headerlink" title="10. 完成TCP服务的的编写"></a>10. 完成TCP服务的的编写</h2><p>请在下方注释下补充代码：</p><p>  # 导入socket模块</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import socket</span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    tcp_evens_socket = socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">    tcp_evens_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True)</span><br><span class="line">    tcp_evens_socket.bind((&quot;&quot;,8080))</span><br><span class="line">    tcp_evens_socket.listen(138)</span><br><span class="line">    coet_socket,ip_mes = tcp_evens_socket.accept()</span><br><span class="line">    recv_data = coet_socket.recv(1025)</span><br><span class="line">    print(recv_data.decode())</span><br><span class="line">    coet_socket.send(&quot;&quot;.encode())</span><br><span class="line">    coet_socket.close()</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;h2 id=&quot;网络编程TC&quot;&gt;&lt;a href=&quot;#网络编程TC&quot; class=&quot;headerlink&quot; title=&quot;网络编程TC&quot;&gt;&lt;/a&gt;网络编程TC&lt;/h2&gt;&lt;h2 id=&quot;网络编程TC-1&quot;&gt;&lt;a href=&quot;#网络编程TC-1&quot; class=&quot;headerl</summary>
      
    
    
    
    
  </entry>
  
</feed>
